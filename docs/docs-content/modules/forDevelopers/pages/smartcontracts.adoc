= Knowledge Base - Smart contracts

The Knowledge Base runs completely on-chain and consists out of different smart contracts which interact with each other.

:toc: 

== `ConfigStorage.sol`
The `ConfigStorage.sol` smart contract is the central component of the Knowledge Base. It stores all the configuration data of the Knowledge Base. The configuration data is stored in various mappings and parameters. The conract also contains functions to set and get the configuration data. The `ConfigStorage.sol` smart contract inherits the `BaseConfigAdmin.sol` smart contract. The `BaseConfigAdmin.sol` smart contract contains functions to add and remove admins and contract admins.

The system differentiated between two types of admins:

* *User Admin* - The user admin can be a professor, teaching assistant or system admin. User admins can change the configuration of the system and add and remove admins.
* *Contract Admin* - The contract admin are contracts that need special permissions to interact with the Knowledge Base. Usually all contracts that are part of the Knowledge Base are contract admins.

This role management system is used to ensure that only trusted users or contracts can access or change the configuration data of the Knowledge Base. This is especially important for the `SBCoin.sol` and validator smart contract. Because only admins should be allowed to transfer _Knowledge Coins_.

=== Parameters
The `ConfigStorage.sol` smart contract stores the configuration data in various parameters. The parameters are used to store the configuration data in a more efficient way. The parameters are:

* `uint128 faucetGas;` - The amount of gas the faucet can send to a user.
* `uint128 faucetBlockNoDifference;` - The amount of blocks need to be passed before the faucet can be used again.

==== Inherited parameters from `BaseConfigAdmin.sol`
The `ConfigStorage.sol` smart contract inherits the following parameters from the `BaseConfigAdmin.sol` smart contract:

* `address[] private admins;` - Stores the addresses of the admins.
* `ContractAdmin[] private contractAdmins;` - Stores the contract admins.

=== Mappings
The `ConfigStorage.sol` smart contract stores the configuration data in various mappings. The mappings are used to store the configuration data in a more efficient way. The mappings are:

* `mapping(uint256 => NOWSemester) semesters;` - Stores the semesters of the Knowledge Base. The key of the mapping is the semester ID. The value of the mapping is a `NOWSemester` struct.

=== Structs
The `ConfigStorage.sol` smart contract stores the configuration data in various structs. The structs are used to store the configuration data in a more efficient way. The structs are:


* `struct NOWSemester {...}` - Stores the data of a semester. The struct contains the following parameters: 
[source,solidity]
----
struct NOWSemester {
    string name; // Name of the semester (e.g. SS22)
    uint256 startBlock; // First block which counts towards this semester
    uint256 endBlock; // Last block which counts towards this semester
    uint256 minKnowledgeCoinAmount; // Amount of knowledge Coins needed to take exam
    uint256 assignmentCounter; // Assignment counter
    uint256[] assignmentIds; // Assignment Ids
    mapping(uint256 => NOWAssignments) assignments; // Assigned assignments
    // TEMP VARIABLES
    uint256 assignmentStartBlock; // Temp var to keep track of lowest start block of all assignments
    uint256 assignmentEndBlock; // Temp var to keep track of highest end block of all assignments
}
----

* `struct NOWAssignment {...}` - Stores the data of an assignment. The struct contains the following parameters:
[source,solidity]
----
struct NOWAssignments {
    string name; // Name of the assignment
    string link; // Link to the assignment
    address validationContractAddress; // Address to the validation contract
    uint256 startBlock; // First block which counts towards this assignment
    uint256 endBlock; // Last block which counts towards this assignment
}
----

==== Inhertited structs from `BaseConfigAdmin.sol`
The `ConfigStorage.sol` smart contract inherits the following structs from the `BaseConfigAdmin.sol` smart contract:

* `struct ContractAdmin {...}` - Stores the data of an admin. The struct contains the following parameters:
[source,solidity]
----
struct ContractAdmin {
    string contractName; // Name of contract
    address contractAddress; // Address of contract
    bool isContractAdmin; // Is contract admin
}
----

=== Functions
The `ConfigStorage.sol` smart contract contains various functions. The paramaters, mappings and structs are used in the functions and can be setted or getted. For detailed descriptions of the functions, please see the comments in the `ConfigStorage.sol` smart contract.

== `SBCoin.sol`
The `SBCoin.sol` smart contract is the contract which stores the _Knowledge Coin_ in short _NOW_. This coin is the main currency of the Knolwedge Base system and the payment students receive for successfully passing tests on their submitted assignments.

All the functions of the contract are described in the comments to the code. The contract is written in Solidity language and compiled with the help of the `solc` compiler.

=== Security

All minting, transfer or burning functions are restricted to user or contract admins. This ensures that only the contract owner can mint new coins and that only the contract owner or the contract admin can transfer coins to other users. So students cannot send coins to each other to cheat the system.

To ensure that students cannot reuse the Knowledge Coins from a previous semester, the Knowledge Coins are bounded to a block range. So students can only use the Knowledge Coins they received in the current semester for qualifying themselves for the current semester exam. This is done by the `mint` function. The `mint` function can only be called by user or contract admins and sends the amount of Knowledge Coins to the student's address and logs the amount with the current block number.

The `burn` function can burn Knowledge Coins from the student's address. This function is also restricted to user or contract admins. Coins are burned by transfering them to a 0x0 address using the `_transfer` function.

The basic `_transfer` and `_approve` functions can only be called by user or contract admins. The `_transfer` function is used to transfer Knowledge Coins from one address to another. The `_approve` function is used to approve another address to spend a certain amount of Knowledge Coins from the sender's address.

The `_transfer` function also keeps track of the change of coins for the block number restriction.

== `FaucetStorage.sol`

The `FaucetStorage.sol` smart contract is the contract which allows students to request ETH. To mock a real system and create an artifical value for ETH. ETH can only be requested after a certain block time. This block difference can be modified in the `ConfigStorage.sol`.

All the functions of the contract are described in the comments to the code. The contract is written in Solidity language and compiled with the help of the `solc` compiler.

Every student can request ETH from the contract. The contract will check if the student has already requested ETH in the defined block difference range. If not the contract will send ETH to the student and store the block number of the transaction. If the student has already requested ETH in the defined block difference range, the contract will not send ETH to the student.

== Assignment Validator 

Here is an explanation of the concept of the assignment validators. 

The job of the assignment validator is to check the validity of the assignment. The contract is doing this by interacting with the assignment of the student and calling different functions and checking the return values or the change of the state of the contract.

Each assignment validator, for convenience sake we call it _validator_, is pack of different contracts. 

image::validator_example.png[]

Contracts in the:

* **/helper** directory are contracts that are used by the validator to check the validity of the assignment. They usually create components like an exchange of registry which are used by the validator or students.

* **/interface** directory are contracts that store the interface of the assignment. They are used by the validator to call the functions of the assignment. The student needs to name his functions in the same way as written in the interface and also define the input and output parameters in the same way.

* base directory contains the validator contracts. The contract without any suffix e.g. _Validator2.sol_ is the main validator contract. The other contracts e.g. _Validator2TaskC.sol_ are used to check single tasks, for this file it only checks tasks which where requested in _Task C_ of the assignment. The vase validator is organizing the calls to the task validators and is also responsible for the payment of the student.

=== Process

The student calls the `test(address)` function using the react frontent. He passes his assignment contract address. The validator than runs various tests on this contract. For each passed task the student receives a certain amount of predefined tokens. **No subpoints can be paid out**. The student can call the `test(address)` function as often as he wants. Each test gets registered and stored in a mapping. The result of the test can be accessed via the test id. This allows the student to see which tasks he passed and which not. The student can also see the reason why a task was not passed.

If the student is happy with the result he can call the `submit(address)` function. This function will test the assignment again and than pays the student the tokens he earned. The student can only call this function once. After the student called this function the validator will not accept any more submit for this assignment.

The contract needs to be:

* Deployed and submitted in block range of the assignment
* The student needs to be the owner of the contract
* No other submission is registered for this assignment by the `msg.sender`

**IMPORTANT:** 

* The student always needs to call the `test(address)` and `submit(address)` function by their own. Because the system checks if the `msg.sender` is the owner of the contract. Furhter the `msg.sender` receives the tokens. Ensure to not try to submit an assignment via another contract.

* The owner of the contract is trackd by the `BaseAssignment.sol` contract. The `BaseAssignment.sol` is inherited by the validator. To set the owner the function `setAssignmentOwner` takes the `msg.sender` as the contract address and the `tx.origin` as the owner. So here the `setAssignmentOwner` **must be called by the student contract**. If the student is using a proxy contract the `setAssignmentOwner` function will log the wrong contract address. This will result in the fact that the student cannot submit the assignment.

* It is only possible to once set the block creation and contract admin.

=== Security

To ensure that the student who submits the assignment is really the owner of the contract. Each student needs to inherit his assignment from the `BaseAssignment.sol` contract. This contract stores calls the corresponding validator contract and stores the _owner_ and _block number_ of creation. By storing the owner and the block number of creation we can ensure that the student is the owner of the contract and that the student is not trying to submit an assignment which is too old. Further the student cannot change the values.

=== Admin

It is possible to remove an already submitted Assignment by calling the `removeSubmittedAssignment(address)` function. This function is of course restricted to user or contract admins. The function will remove the assignment from the mapping and the student can submit the assignment again. BUT the student will also lose the tokens he already earned (`burn` function used).